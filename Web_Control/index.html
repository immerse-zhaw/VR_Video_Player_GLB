<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Video Player Control</title>
    <style>
    body { margin: 0; font-family: Arial, sans-serif; background: #222; color: #eee; padding: 1em; box-sizing: border-box; min-height: 100vh; }
    #layout { display: flex; gap: 1em; align-items: stretch; justify-content: center; width: 100%; height: calc(100vh - 2em); flex-wrap: wrap; }
    .column { display: flex; gap: 1em; align-items: stretch; flex: 1; min-width: 300px; height: fit-content; }
    .column.vertical { flex-direction: column; height: 100%; }
    #leftColumn { flex: 1; }
    #middleColumn { flex: 2; max-width: 400px; }
    #rightColumn { flex: 1; }
    .panel { background: #333; padding: 1em; border-radius: 12px; box-shadow: 0 0 18px rgba(0,0,0,0.4); display: flex; flex-direction: column; gap: 0.75em; flex: 1; }
    .panel h2, .panel h3 { margin: 0 0 0.5em 0; padding: 0; }
    #mainPanel.panel { flex: 2; min-height: 500px; align-items: stretch; justify-content: space-between; }
    #videoListPanel.panel { flex: 1; min-height: 300px; }
    #videoUploadPanel.panel { flex: 0 0 140px; }
    #glbPanel { flex: 0 0 140px; transition: background 0.2s ease, box-shadow 0.2s ease; }
    #glbPreviewPanel { flex: 1; min-height: 300px; }

    #glbPanel.drag-hover, #videoUploadPanel.drag-hover { background: #2d2d2d; box-shadow: 0 0 20px #005fa3; }
    #glbDropZone { width: 100%; height: 80px; display: flex; align-items: center; justify-content: center; background: #232323; border-radius: 12px; color: #aaa; cursor: pointer; transition: background 0.2s ease, box-shadow 0.2s, border-color 0.2s; border: 2.5px dashed #1976d2; box-sizing: border-box; font-size: 0.9em; text-align: center; }
    #glbDropText { width: 100%; text-align: center; font-size: 0.98em; line-height: 1.3; display: block; }
    #glbDropZone.hover, #videoDropZone.hover { background: #2d3540; border-color: #42a5f5; box-shadow: 0 0 0 2px #1976d2; }
    #glbUploadStatus, #videoUploadStatus { min-height: 1em; }
    #glbPreview { width: 100%; height: 320px; border-radius: 10px; background: #111; display: none; }
    #glbPreviewPlaceholder { padding: 1.5em; border-radius: 10px; background: #2c2c2c; text-align: center; color: #999; height: 200px; display: flex; align-items: center; justify-content: center; flex-direction: column; }
        input, button { margin: 0.5em; padding: 0.5em; border-radius: 5px; border: none; max-width: 100%; box-sizing: border-box; }
        button { background: #0078d7; color: #fff; cursor: pointer; }
        button.toggled { background: #005fa3; }
        button:hover { background: #005fa3; }
        .toggle-buttons { display: flex; justify-content: flex-end; gap: 1em; flex-wrap: wrap; }
        .device-inputs { display: flex; gap: 0.5em; flex-wrap: wrap; align-items: center; justify-content: center; width: 100%; margin: 0 auto 1em auto; }
        #videoContainer { margin: 1em auto 0 auto !important; width: 100%; max-width: 800px; display: flex; flex-direction: column; align-items: center; flex: 1; }
        #videoPreview, #videoPlaceholder { margin: 0 auto; width: 100%; }
    #videoPreview { height: auto; aspect-ratio: 16/9; object-fit: contain; max-height: 400px; }
    #videoPlaceholder { aspect-ratio: 16/9; max-height: 400px; display: flex; align-items: center; justify-content: center; flex-direction: column; }
    #deviceList { max-height: 150px; overflow-y: auto; border: 1px solid #444; border-radius: 8px; background: #222; padding: 0.35em 0.5em; display: flex; flex-direction: column; gap: 0.35em; scrollbar-width: thin; }
    #deviceList::-webkit-scrollbar { width: 6px; }
    #deviceList::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
    .device-entry { background: #2a2a2a; border-radius: 6px; padding: 0.45em 0.55em; display: flex; flex-direction: column; gap: 0.35em; font-size: 0.85em; box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03); }
    .device-entry-header { display: flex; align-items: center; gap: 0.5em; }
    .device-info { display: flex; align-items: center; gap: 0.4em; font-weight: 600; }
    .device-status-indicator { width: 10px; height: 10px; border-radius: 50%; border: 1px solid #111; display: inline-block; }
    .device-status-connected { background: #4caf50; }
    .device-status-connecting { background: #ffeb3b; }
    .device-status-disconnected { background: #f44336; }
    .device-entry-buttons { margin-left: auto; display: flex; align-items: center; gap: 0.3em; }
    .device-entry-buttons button { font-size: 0.72em; padding: 0.25em 0.6em; border-radius: 4px; }
    .device-entry-status { font-size: 0.72em; color: #bbb; display: flex; justify-content: space-between; align-items: center; gap: 0.3em; }
    .device-progress-wrapper { display: flex; flex-direction: column; gap: 0.25em; }
    .device-progress-label { font-size: 0.7em; color: #9cd3ff; }
    .device-progress { height: 6px; background: #1a1a1a; border-radius: 4px; overflow: hidden; }
    .device-progress-bar { height: 100%; width: 0%; background: #42a5f5; transition: width 0.2s ease; }
    .device-progress-bar.complete { background: #66bb6a; }
    .device-progress-bar.failed { background: #ef5350; }
    #status { min-height: 1.2em; font-size: 0.85em; text-align: center; color: #8bc34a; }

        /* Responsive Design */
        @media (max-width: 1200px) {
            body { padding: 0.5em; }
            #layout { gap: 0.5em; }
            .column { min-width: 250px; }
            #middleColumn { max-width: 350px; }
            .panel { padding: 1em; }
        }

        @media (max-width: 900px) {
            #layout { flex-direction: column; height: auto; }
            .column { flex-direction: row; flex-wrap: wrap; min-width: 100%; }
            .column.vertical { flex-direction: row; flex-wrap: wrap; }
            #leftColumn, #middleColumn, #rightColumn { flex: none; max-width: 100%; }
            .panel { min-width: 280px; max-width: 100%; margin: 0.25em; box-sizing: border-box; }
            #mainPanel.panel { min-height: 400px; }
        }

        @media (max-width: 600px) {
            body { padding: 0.25em; }
            #layout { flex-direction: column; gap: 0.25em; }
            .column { flex-direction: column; flex-wrap: nowrap; }
            .column.vertical { flex-direction: column; }
            #leftColumn, #middleColumn, #rightColumn { flex: none; max-width: 100%; }
            .panel { min-width: 100%; max-width: 100%; margin: 0; padding: 0.75em; box-sizing: border-box; }
            #mainPanel.panel { min-height: 350px; }
            #videoListPanel.panel { min-height: 200px; }
            #glbPreviewPanel { min-height: 250px; }
        }
    </style>
</head>
<body>
    <div id="layout">
        <div id="leftColumn" class="column vertical">
            <div id="mainPanel" class="panel">
                <h2>VR Video Player Control</h2>
                <div style="display: flex; flex-direction: column; gap: 0.75em; margin-bottom: 1em;">
                    <div class="device-inputs">
                        <input type="text" id="deviceIp" placeholder="Device IP (e.g. 192.168.1.10)" size="18">
                        <input type="number" id="devicePort" placeholder="Port" min="1" max="65535" value="8080" style="width:80px;">
                        <button onclick="addDevice()">Add Device</button>
                    </div>
                    <div id="deviceList"></div>
                    <div style="display: flex; flex-direction: column; gap: 0.3em; align-items: center;">
                        <input type="text" id="videoPath" placeholder="Enter video URL (http://...) or local filename" size="50" style="text-align: center;">
                        <div style="font-size: 0.8em; color: #aaa; text-align: center; line-height: 1.2;">
                            HTTP/HTTPS URLs • Local filenames • Full file paths
                        </div>
                    </div>
                    <div style="display: flex; justify-content: center; gap: 0.5em;">
                        <button onclick="sendPlay()">Play</button>
                        <button id="pauseResumeBtn" onclick="togglePauseResume()">Pause</button>
                        <button id="toggleMode" onclick="toggleMode()">Switch to 360 Mode</button>
                    </div>
                    <div id="status"></div>
                </div>
                <div id="videoContainer">
                    <video id="videoPreview" controls style="width:100%; display:none;"></video>
                    <div id="videoPlaceholder" style="background:#555; text-align:center; border-radius:5px;">
                        <p>Video Preview</p>
                        <p style="font-size:0.8em; opacity:0.7;">Play a video URL or select from Content/Videos to see preview</p>
                    </div>
                </div>
            </div>
        </div>
        <div id="middleColumn" class="column vertical">
            <div id="videoUploadPanel" class="panel">
                <h3>Select Video Files</h3>
                <div id="videoDropZone" style="width: 100%; height: 80px; display: flex; align-items: center; justify-content: center; background: #232323; border-radius: 12px; color: #aaa; cursor: pointer; transition: background 0.2s ease, box-shadow 0.2s, border-color 0.2s; border: 2.5px dashed #1976d2; box-sizing: border-box; font-size: 0.9em; text-align: center;">
                    <span id="videoDropText">Drag & Drop or click to select video files</span>
                </div>
                <div id="videoUploadStatus" style="min-height: 1em;"></div>
            </div>
            <div id="videoListPanel" class="panel">
                <h3 style="text-align:center;">Available Videos</h3>
                <div style="display: flex; gap: 0.3em; margin-bottom: 0.5em; flex-wrap: wrap;">
                    <button id="btnServer2D" onclick="showVideoList('server2D')" style="flex: 1; min-width: 60px; font-size: 0.8em; padding: 0.3em; background: #005fa3;">Server 2D</button>
                    <button id="btnServer360" onclick="showVideoList('server360')" style="flex: 1; min-width: 60px; font-size: 0.8em; padding: 0.3em;">Server 360</button>
                    <button id="btnDevice" onclick="showVideoList('device')" style="flex: 1; min-width: 60px; font-size: 0.8em; padding: 0.3em;">Device</button>
                </div>
                <ul id="videoList" style="list-style:none; padding:0; margin:0; height: 100%; overflow-y: auto; flex: 1;"></ul>
            </div>
        </div>
        <div id="rightColumn" class="column vertical">
            <div id="glbPanel" class="panel">
                <h3>Select 3D Model (GLB/GLTF)</h3>
                <div id="glbDropZone">
                    <span id="glbDropText">Drag & Drop .glb or .gltf file here, <br> or click to browse</span>
                </div>
                <div id="glbUploadStatus"></div>
            </div>
            <div id="glbPreviewPanel" class="panel">
                <h3>GLB/GLTF Models</h3>
                <div style="display: flex; gap: 0.3em; margin-bottom: 0.5em; flex-wrap: wrap;">
                    <button id="btnServerGLB" onclick="showGLBList('server')" style="flex: 1; min-width: 70px; font-size: 0.8em; padding: 0.3em; background: #005fa3;">Server GLB</button>
                    <button id="btnDeviceGLB" onclick="showGLBList('device')" style="flex: 1; min-width: 70px; font-size: 0.8em; padding: 0.3em;">Device GLB</button>
                </div>
                <ul id="glbList" style="list-style:none; padding:0; margin:0; flex: 1; overflow-y: auto; max-height: 180px;"></ul>
                <div style="margin-top: 0.5em;">
                    <h4 style="margin: 0.5em 0;">Preview</h4>
                    <model-viewer id="glbPreview" camera-controls autoplay style="width: 100%; height: 300px; border-radius: 10px; background: #111; display: none;"></model-viewer>
                    <div id="glbPreviewPlaceholder" style="padding: 1em; border-radius: 10px; background: #2c2c2c; text-align: center; color: #999; height: 300px; display: flex; align-items: center; justify-content: center; flex-direction: column; font-size: 0.9em;">
                        <p>3D Model Preview</p>
                        <p style="font-size:0.85em; opacity:0.7;">Select a GLB/GLTF to preview</p>
                    </div>
                </div>
            </div>

        </div>
    </div>
    <input type="file" id="glbFileInput" accept=".glb,.gltf" hidden>
    <input type="file" id="videoFileInput" accept=".mp4,.mov,.avi,.mkv,.webm" multiple hidden>
    <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
    <script>
        // Device management
        const devices = [];
        let is360Mode = false;
        const WS_PORT_SCRIPT = 8080; // Change this if you want a different default port in the script
        const LOCAL_PREVIEW_FOLDER = 'Content/Videos';
        const SERVER_URL = 'https://xr.engineering.zhaw.ch';
        let previewAvailable = false;
        let serverVideos2D = [];
        let serverVideos360 = [];
        let serverGLBs = [];
        let deviceVideos = {}; // deviceId -> array of videos
        let deviceGLBs = {}; // deviceId -> array of GLBs
        const deviceDownloads = {};
        const deviceDownloadTimeouts = {};
        let currentVideoView = 'server2D'; // 'server2D', 'server360', 'device'
        let currentGLBView = 'server'; // 'server', 'device'
        let serverFetchError = null;
        let isLocalPreview = false;
        let currentVideoPath = '';

        function showPreviewPlaceholder(message) {
            const videoPreview = document.getElementById('videoPreview');
            const placeholder = document.getElementById('videoPlaceholder');
            if (!videoPreview || !placeholder) return;

            previewAvailable = false;
            videoPreview._programmaticPause = true;
            videoPreview._programmaticSeek = true;
            videoPreview.pause();
            videoPreview.onerror = null;
            videoPreview.onloadeddata = null;
            try {
                videoPreview.removeAttribute('src');
                videoPreview.load();
            } catch (e) {}
            videoPreview.style.display = 'none';
            placeholder.style.display = 'block';
            placeholder.innerHTML = message || '<p>Video Preview</p><p style="font-size:0.8em; opacity:0.7;">Play an HTTP video URL to see preview here</p>';
        }

        function setPreviewForPath(path) {
            currentVideoPath = path || '';
            const videoPreview = document.getElementById('videoPreview');
            const placeholder = document.getElementById('videoPlaceholder');
            if (!videoPreview || !placeholder) return;

            videoPreview.onerror = null;
            videoPreview.onloadeddata = null;

            if (!path) {
                showPreviewPlaceholder();
                return;
            }

            const rawName = path.split('/').pop() || path;
            const fileName = decodeURIComponent(rawName);
            let source = path;

            if (path.startsWith('http')) {
                isLocalPreview = false;
                source = path;
            } else {
                isLocalPreview = true;
                const localRelativePath = `${LOCAL_PREVIEW_FOLDER}/${fileName}`;
                source = encodeURI(localRelativePath);
            }

            previewAvailable = false;
            videoPreview.style.display = 'block';
            placeholder.style.display = 'none';

            videoPreview.onerror = () => {
                showPreviewPlaceholder(`<p>Preview unavailable for ${fileName}</p><p style="font-size:0.8em; opacity:0.7;">Ensure the file exists in ${LOCAL_PREVIEW_FOLDER}/</p>`);
            };
            videoPreview.onloadeddata = () => {
                previewAvailable = true;
                videoPreview._programmaticSeek = false;
                videoPreview.onloadeddata = null;
            };

            videoPreview._programmaticPlay = true;
            videoPreview._programmaticSeek = true;
            videoPreview.src = source;
            try {
                videoPreview.load();
                videoPreview.play().catch(() => {});
            } catch (e) {}
        }

        function sendSeek(timeInSeconds) {
            const time = Number(timeInSeconds);
            if (Number.isNaN(time)) return;
            getConnectedDevices().forEach(device => {
                device.ws.send(JSON.stringify({ action: 'seek', time }));
            });
        }

        function addDevice() {
            const ip = document.getElementById('deviceIp').value.trim();
            const port = document.getElementById('devicePort').value.trim();
            if (!ip || !port) return;
            const id = ip + ':' + port;
            if (devices.find(d => d.id === id)) return;
            const wsUrl = `ws://${ip}:${port}`;
            const device = {
                id,
                ip,
                port,
                ws: null,
                status: 'connecting',
            };
            devices.push(device);
            updateDeviceList();
            connectDevice(device);
        }

        function connectDevice(device) {
            device.status = 'connecting';
            updateDeviceList();
            device.ws = new WebSocket(`ws://${device.ip}:${device.port}`);
            device.ws.onopen = () => {
                device.status = 'connected';
                delete deviceDownloads[device.id];
                if (deviceDownloadTimeouts[device.id]) {
                    clearTimeout(deviceDownloadTimeouts[device.id]);
                    delete deviceDownloadTimeouts[device.id];
                }
                updateDeviceList();
                requestVideoList(device);
                
                // Fetch server files when first device connects
                if (getConnectedDevices().length === 1) {
                    fetchServerFiles();
                }
            };
            device.ws.onclose = () => {
                device.status = 'disconnected';
                if (deviceDownloadTimeouts[device.id]) {
                    clearTimeout(deviceDownloadTimeouts[device.id]);
                    delete deviceDownloadTimeouts[device.id];
                }
                delete deviceDownloads[device.id];
                updateDeviceList();
            };
            device.ws.onerror = () => {
                device.status = 'disconnected';
                if (deviceDownloadTimeouts[device.id]) {
                    clearTimeout(deviceDownloadTimeouts[device.id]);
                    delete deviceDownloadTimeouts[device.id];
                }
                delete deviceDownloads[device.id];
                updateDeviceList();
            };
            device.ws.onmessage = (msg) => {
                try {
                    const data = JSON.parse(msg.data);
                    if (data.type === 'videoList') {
                        device.videoList = data.files;
                        deviceVideos[device.id] = data.files;
                        updateVideoListPanel();
                    } else if (data.type === 'glbList') {
                        device.glbList = data.files;
                        deviceGLBs[device.id] = data.files;
                        updateGLBListPanel();
                    } else if (data.type === 'downloadStatus') {
                        handleDownloadStatus(device, data);
                        return;
                    }
                    // Sync browser video preview with app pause/resume
                    if (typeof data === 'string') return;
                    const videoPreview = document.getElementById('videoPreview');
                    const btn = document.getElementById('pauseResumeBtn');
                    if (data.action === 'pause') {
                        if (videoPreview && videoPreview.src && !videoPreview.paused) {
                            videoPreview._programmaticPause = true;
                            videoPreview.pause();
                        }
                        if (btn) btn.textContent = 'Resume';
                    } else if (data.action === 'resume') {
                        if (videoPreview && videoPreview.src && videoPreview.paused) {
                            videoPreview._programmaticPlay = true;
                            videoPreview.play().catch(() => {});
                        }
                        if (btn) btn.textContent = 'Pause';
                    } else if (data.action === 'seek' && typeof data.time === 'number') {
                        if (videoPreview && videoPreview.src) {
                            videoPreview._programmaticSeek = true;
                            try {
                                videoPreview.currentTime = data.time;
                            } catch (e) {}
                        }
                    }
                } catch (e) {}
            };
        }

        function requestVideoList(device) {
            if (device && device.ws && device.ws.readyState === WebSocket.OPEN) {
                device.ws.send(JSON.stringify({ action: 'listVideos' }));
                device.ws.send(JSON.stringify({ action: 'listGLBs' }));
            }
        }

        // Server API functions
        function normalizeServerList(data) {
            if (!data) {
                return [];
            }

            const items = Array.isArray(data)
                ? data
                : Array.isArray(data.files)
                    ? data.files
                    : [];

            return items.map(item => {
                if (typeof item === 'string') {
                    return item;
                }
                if (item && typeof item === 'object') {
                    return item.name || item.filename || item.file || '';
                }
                return '';
            }).filter(Boolean);
        }

        async function fetchServerFiles() {
            try {
                const responses = await Promise.all([
                    fetch(`${SERVER_URL}/list/2D`, { method: 'GET' }),
                    fetch(`${SERVER_URL}/list/360`, { method: 'GET' }),
                    fetch(`${SERVER_URL}/list/GLB`, { method: 'GET' })
                ]);

                responses.forEach((response, index) => {
                    if (!response.ok) {
                        throw new Error(`Server responded with ${response.status} for ${['2D', '360', 'GLB'][index]} list`);
                    }
                });

                const [videos2D, videos360, glbs] = await Promise.all(responses.map(r => r.json()));

                serverVideos2D = normalizeServerList(videos2D);
                serverVideos360 = normalizeServerList(videos360);
                serverGLBs = normalizeServerList(glbs);
                serverFetchError = null;
            } catch (error) {
                console.error('Failed to fetch server files:', error);
                serverFetchError = `Unable to reach server (${error.message || 'see console'}).`;
                serverVideos2D = [];
                serverVideos360 = [];
                serverGLBs = [];
            } finally {
                updateVideoListPanel();
                updateGLBListPanel();
            }
        }

        async function uploadFileToServer(file, folder) {
            const formData = new FormData();
            formData.append('file', file);
            formData.append('folder', folder);

            const response = await fetch(`${SERVER_URL}/upload`, {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                throw new Error(`Upload failed: ${response.statusText}`);
            }
            
            return response.json();
        }

        async function downloadFileToDevice(filename, folder, deviceId) {
            const device = devices.find(d => d.id === deviceId);
            if (!device || !device.ws || device.ws.readyState !== WebSocket.OPEN) {
                throw new Error('Device not connected');
            }

            deviceDownloads[deviceId] = {
                filename,
                folder,
                state: 'queued',
                progress: 0,
                message: ''
            };
            if (deviceDownloadTimeouts[deviceId]) {
                clearTimeout(deviceDownloadTimeouts[deviceId]);
                delete deviceDownloadTimeouts[deviceId];
            }
            updateDeviceList();
            setStatus(`Preparing ${filename} for ${device.ip}...`);

            let serverUrl = `${SERVER_URL}/VR_content/Videos/${folder}/${filename}`;
            if (folder === 'GLB') {
                serverUrl = `${SERVER_URL}/VR_content/GLB/${filename}`;
            }

            try {
                device.ws.send(JSON.stringify({ 
                    action: 'downloadFile', 
                    url: serverUrl, 
                    filename: filename,
                    folder: folder
                }));
            } catch (error) {
                setStatus(`Failed to queue ${filename} for ${device.ip}`, 'error');
                delete deviceDownloads[deviceId];
                updateDeviceList();
                throw error;
            }
        }





        // Select the first connected device by default
        function getSelectedDevice() {
            return getConnectedDevices()[0] || null;
        }

        function showVideoList(viewType) {
            currentVideoView = viewType;
            
            // Update button states
            document.getElementById('btnServer2D').style.background = viewType === 'server2D' ? '#005fa3' : '#0078d7';
            document.getElementById('btnServer360').style.background = viewType === 'server360' ? '#005fa3' : '#0078d7';
            document.getElementById('btnDevice').style.background = viewType === 'device' ? '#005fa3' : '#0078d7';
            
            // Refresh video lists when switching tabs
            if (viewType === 'server2D' || viewType === 'server360') {
                fetchServerFiles();
            } else if (viewType === 'device') {
                // Request video list from all connected devices
                getConnectedDevices().forEach(device => {
                    requestVideoList(device);
                });
            }
            
            updateVideoListPanel();
        }

        function showGLBList(viewType) {
            currentGLBView = viewType;
            
            // Update button states
            document.getElementById('btnServerGLB').style.background = viewType === 'server' ? '#005fa3' : '#0078d7';
            document.getElementById('btnDeviceGLB').style.background = viewType === 'device' ? '#005fa3' : '#0078d7';
            
            // Refresh GLB lists when switching tabs
            if (viewType === 'server') {
                fetchServerFiles();
            } else if (viewType === 'device') {
                // Request GLB list from all connected devices
                getConnectedDevices().forEach(device => {
                    requestVideoList(device);
                });
            }
            
            updateGLBListPanel();
        }

        function updateVideoListPanel() {
            const ul = document.getElementById('videoList');
            ul.innerHTML = '';
            
            if (currentVideoView === 'server2D') {
                updateServerVideosList(ul, serverVideos2D, '2D');
            } else if (currentVideoView === 'server360') {
                updateServerVideosList(ul, serverVideos360, '360');
            } else if (currentVideoView === 'device') {
                updateDeviceVideosList(ul);
            }
        }

        function updateServerVideosList(ul, videoList, folder) {
            ul.innerHTML = '';
            
            videoList.forEach(filename => {
                const li = createServerVideoItem(filename, folder);
                ul.appendChild(li);
            });
            
            if (videoList.length === 0) {
                const message = serverFetchError || `No ${folder} videos on server`;
                ul.innerHTML = `<li style="color:#aaa;text-align:center;padding:0.5em;">${message}</li>`;
            }
        }

        function createServerVideoItem(filename, folder) {
            const li = document.createElement('li');
            li.style.padding = '0.5em';
            li.style.borderBottom = '1px solid #444';
            li.style.display = 'flex';
            li.style.justifyContent = 'space-between';
            li.style.alignItems = 'center';

            const nameSpan = document.createElement('span');
            nameSpan.textContent = filename;
            nameSpan.style.flex = '1';
            nameSpan.style.marginRight = '0.5em';

            const buttonContainer = document.createElement('div');
            buttonContainer.style.display = 'flex';
            buttonContainer.style.gap = '0.3em';

            // Play button (stream)
            const playBtn = document.createElement('button');
            playBtn.textContent = 'Stream';
            playBtn.style.fontSize = '0.8em';
            playBtn.style.padding = '0.2em 0.4em';
            playBtn.style.background = '#0078d7';
            playBtn.style.color = 'white';
            playBtn.style.border = 'none';
            playBtn.style.borderRadius = '3px';
            playBtn.onclick = () => streamVideoFromServer(filename, folder);

            // Download button
            const downloadBtn = document.createElement('button');
            downloadBtn.textContent = 'Download';
            downloadBtn.style.fontSize = '0.8em';
            downloadBtn.style.padding = '0.2em 0.4em';
            downloadBtn.style.background = '#66bb6a';
            downloadBtn.style.color = 'white';
            downloadBtn.style.border = 'none';
            downloadBtn.style.borderRadius = '3px';
            downloadBtn.title = 'Download to device';
            downloadBtn.onclick = () => downloadVideoToAllDevices(filename, folder);

            buttonContainer.appendChild(playBtn);
            buttonContainer.appendChild(downloadBtn);
            li.appendChild(nameSpan);
            li.appendChild(buttonContainer);

            return li;
        }

        function updateDeviceVideosList(ul) {
            ul.innerHTML = '';
            
            const connectedDevices = getConnectedDevices();
            if (connectedDevices.length === 0) {
                ul.innerHTML = '<li style="color:#aaa;text-align:center;padding:0.5em;">No devices connected</li>';
                return;
            }

            // Collect all unique videos from all devices
            const allDeviceVideos = new Set();
            connectedDevices.forEach(device => {
                if (deviceVideos[device.id]) {
                    deviceVideos[device.id].forEach(videoPath => {
                        const filename = videoPath.split('/').pop();
                        allDeviceVideos.add(filename);
                    });
                }
            });

            if (allDeviceVideos.size === 0) {
                ul.innerHTML = '<li style="color:#aaa;text-align:center;padding:0.5em;">No videos found on devices</li>';
                return;
            }

            allDeviceVideos.forEach(filename => {
                const li = createDeviceVideoItem(filename, connectedDevices);
                ul.appendChild(li);
            });
        }

        function createDeviceVideoItem(filename, connectedDevices) {
            const li = document.createElement('li');
            li.style.padding = '0.5em';
            li.style.borderBottom = '1px solid #444';

            const header = document.createElement('div');
            header.style.display = 'flex';
            header.style.justifyContent = 'space-between';
            header.style.alignItems = 'center';

            const nameSpan = document.createElement('span');
            nameSpan.textContent = filename;
            nameSpan.style.flex = '1';

            const playBtn = document.createElement('button');
            playBtn.textContent = 'Play';
            playBtn.style.fontSize = '0.8em';
            playBtn.style.padding = '0.2em 0.4em';
            playBtn.style.background = '#0078d7';
            playBtn.style.color = 'white';
            playBtn.style.border = 'none';
            playBtn.style.borderRadius = '3px';
            playBtn.onclick = () => playDeviceVideo(filename);

            header.appendChild(nameSpan);
            header.appendChild(playBtn);

            // Check which devices have this file
            const devicesWithFile = [];
            const devicesWithoutFile = [];
            
            connectedDevices.forEach(device => {
                const hasFile = deviceVideos[device.id] && 
                    deviceVideos[device.id].some(path => path.includes(filename));
                if (hasFile) {
                    devicesWithFile.push(device);
                } else {
                    devicesWithoutFile.push(device);
                }
            });

            li.appendChild(header);

            // Show warning if not all devices have the file
            if (devicesWithoutFile.length > 0) {
                const warning = document.createElement('div');
                warning.style.fontSize = '0.8em';
                warning.style.color = '#ff9800';
                warning.style.marginTop = '0.3em';
                warning.style.paddingLeft = '0.5em';
                warning.innerHTML = `⚠️ Missing on: ${devicesWithoutFile.map(d => d.ip).join(', ')}`;
                li.appendChild(warning);
            }

            return li;
        }

        function updateGLBListPanel() {
            const ul = document.getElementById('glbList');
            
            if (currentGLBView === 'server') {
                updateServerGLBsList(ul);
            } else {
                updateDeviceGLBsList(ul);
            }
        }

        function updateServerGLBsList(ul) {
            ul.innerHTML = '';
            
            serverGLBs.forEach(filename => {
                const li = createServerGLBItem(filename);
                ul.appendChild(li);
            });
            
            if (serverGLBs.length === 0) {
                const message = serverFetchError || 'No GLB models on server';
                ul.innerHTML = `<li style="color:#aaa;text-align:center;padding:0.5em;">${message}</li>`;
            }
        }

        function createServerGLBItem(filename) {
            const li = document.createElement('li');
            li.style.padding = '0.5em';
            li.style.borderBottom = '1px solid #444';
            li.style.display = 'flex';
            li.style.justifyContent = 'space-between';
            li.style.alignItems = 'center';

            const nameSpan = document.createElement('span');
            nameSpan.textContent = filename;
            nameSpan.style.flex = '1';
            nameSpan.style.marginRight = '0.5em';
            nameSpan.style.cursor = 'pointer';
            nameSpan.onclick = () => previewGLBFromServer(filename);

            const buttonContainer = document.createElement('div');
            buttonContainer.style.display = 'flex';
            buttonContainer.style.gap = '0.3em';

            // Download button
            const downloadBtn = document.createElement('button');
            downloadBtn.textContent = 'Download';
            downloadBtn.style.fontSize = '0.8em';
            downloadBtn.style.padding = '0.2em 0.4em';
            downloadBtn.style.background = '#66bb6a';
            downloadBtn.style.color = 'white';
            downloadBtn.style.border = 'none';
            downloadBtn.style.borderRadius = '3px';
            downloadBtn.title = 'Download to device';
            downloadBtn.onclick = () => downloadGLBToAllDevices(filename);

            buttonContainer.appendChild(downloadBtn);
            li.appendChild(nameSpan);
            li.appendChild(buttonContainer);

            return li;
        }

        function updateDeviceGLBsList(ul) {
            ul.innerHTML = '';
            
            const connectedDevices = getConnectedDevices();
            if (connectedDevices.length === 0) {
                ul.innerHTML = '<li style="color:#aaa;text-align:center;padding:0.5em;">No devices connected</li>';
                return;
            }

            // Collect all unique GLBs from all devices
            const allDeviceGLBs = new Set();
            connectedDevices.forEach(device => {
                if (deviceGLBs[device.id]) {
                    deviceGLBs[device.id].forEach(glbPath => {
                        const filename = glbPath.split('/').pop();
                        allDeviceGLBs.add(filename);
                    });
                }
            });

            if (allDeviceGLBs.size === 0) {
                ul.innerHTML = '<li style="color:#aaa;text-align:center;padding:0.5em;">No GLB models found on devices</li>';
                return;
            }

            allDeviceGLBs.forEach(filename => {
                const li = createDeviceGLBItem(filename, connectedDevices);
                ul.appendChild(li);
            });
        }

        function createDeviceGLBItem(filename, connectedDevices) {
            const li = document.createElement('li');
            li.style.padding = '0.5em';
            li.style.borderBottom = '1px solid #444';

            const header = document.createElement('div');
            header.style.display = 'flex';
            header.style.justifyContent = 'space-between';
            header.style.alignItems = 'center';

            const nameSpan = document.createElement('span');
            nameSpan.textContent = filename;
            nameSpan.style.flex = '1';
            nameSpan.style.cursor = 'pointer';
            nameSpan.onclick = () => importGLBFromDevice(filename);

            const importBtn = document.createElement('button');
            importBtn.textContent = 'Import';
            importBtn.style.fontSize = '0.8em';
            importBtn.style.padding = '0.2em 0.4em';
            importBtn.style.background = '#0078d7';
            importBtn.style.color = 'white';
            importBtn.style.border = 'none';
            importBtn.style.borderRadius = '3px';
            importBtn.onclick = () => importGLBFromDevice(filename);

            header.appendChild(nameSpan);
            header.appendChild(importBtn);

            // Check which devices have this file
            const devicesWithFile = [];
            const devicesWithoutFile = [];
            
            connectedDevices.forEach(device => {
                const hasFile = deviceGLBs[device.id] && 
                    deviceGLBs[device.id].some(path => path.includes(filename));
                if (hasFile) {
                    devicesWithFile.push(device);
                } else {
                    devicesWithoutFile.push(device);
                }
            });

            li.appendChild(header);

            // Show warning if not all devices have the file
            if (devicesWithoutFile.length > 0) {
                const warning = document.createElement('div');
                warning.style.fontSize = '0.8em';
                warning.style.color = '#ff9800';
                warning.style.marginTop = '0.3em';
                warning.style.paddingLeft = '0.5em';
                warning.innerHTML = `⚠️ Missing on: ${devicesWithoutFile.map(d => d.ip).join(', ')}`;
                li.appendChild(warning);
            }

            return li;
        }

        function playDeviceVideo(filename) {
            const device = getSelectedDevice();
            if (!device) return;
            
            // Find the full path for this filename
            const fullPath = deviceVideos[device.id]?.find(path => path.includes(filename));
            if (fullPath) {
                device.ws.send(JSON.stringify({ action: 'play', path: fullPath }));
                document.getElementById('videoPath').value = fullPath;
                setPreviewForPath(fullPath);
                const btn = document.getElementById('pauseResumeBtn');
                if (btn) btn.textContent = 'Pause';
            }
        }

        function sendPlay() {
            const path = document.getElementById('videoPath').value;
            getConnectedDevices().forEach(device => {
                device.ws.send(JSON.stringify({ action: 'play', path }));
            });
            setPreviewForPath(path);
            const videoPreview = document.getElementById('videoPreview');
            if (videoPreview) {
                videoPreview.currentTime = 0;
            }
            const btn = document.getElementById('pauseResumeBtn');
            if (btn) btn.textContent = 'Pause';
        }

        function streamVideoFromServer(filename, folder) {
            const serverUrl = `${SERVER_URL}/VR_content/Videos/${folder}/${filename}`;
            const connectedDevices = getConnectedDevices();
            if (connectedDevices.length === 0) {
                setStatus('No devices connected', 'warn');
                return;
            }
            connectedDevices.forEach(device => {
                device.ws.send(JSON.stringify({ action: 'play', path: serverUrl }));
            });
            document.getElementById('videoPath').value = serverUrl;
            setPreviewForPath(serverUrl);
            const videoPreview = document.getElementById('videoPreview');
            if (videoPreview) {
                videoPreview.currentTime = 0;
            }
            const btn = document.getElementById('pauseResumeBtn');
            if (btn) btn.textContent = 'Pause';
        }

        function downloadVideoToAllDevices(filename, folder) {
            const connectedDevices = getConnectedDevices();
            
            if (connectedDevices.length === 0) {
                setStatus('No devices connected', 'warn');
                return;
            }

            connectedDevices.forEach(device => {
                downloadFileToDevice(filename, folder, device.id).catch(error => {
                    console.error(`Failed to download ${filename} to device ${device.ip}:`, error);
                    setStatus(`Failed to start download on ${device.ip}`, 'error');
                });
            });
            setStatus(`Downloading ${filename} to ${connectedDevices.length} device(s)...`, 'info');
        }

        function downloadGLBToAllDevices(filename) {
            const connectedDevices = getConnectedDevices();
            
            if (connectedDevices.length === 0) {
                setStatus('No devices connected', 'warn');
                return;
            }

            connectedDevices.forEach(device => {
                downloadFileToDevice(filename, 'GLB', device.id).catch(error => {
                    console.error(`Failed to download ${filename} to device ${device.ip}:`, error);
                    setStatus(`Failed to start download on ${device.ip}`, 'error');
                });
            });
            setStatus(`Downloading ${filename} to ${connectedDevices.length} device(s)...`, 'info');
        }

        function previewGLBFromServer(filename) {
            const serverUrl = `${SERVER_URL}/VR_content/GLB/${filename}`;
            const glbPreview = document.getElementById('glbPreview');
            const placeholder = document.getElementById('glbPreviewPlaceholder');
            
            glbPreview.src = serverUrl;
            glbPreview.style.display = 'block';
            placeholder.style.display = 'none';
        }

        function importGLBFromDevice(filename) {
            const connectedDevices = getConnectedDevices();
            
            if (connectedDevices.length === 0) {
                setStatus('No devices connected', 'warn');
                return;
            }

            connectedDevices.forEach(device => {
                device.ws.send(JSON.stringify({ action: 'importGLB', name: filename }));
            });
        }

        function updateDeviceList() {
            const list = document.getElementById('deviceList');
            if (!list) return;
            list.innerHTML = '';

            if (devices.length === 0) {
                const empty = document.createElement('div');
                empty.style.fontSize = '0.8em';
                empty.style.textAlign = 'center';
                empty.style.opacity = '0.6';
                empty.textContent = 'No devices added yet';
                list.appendChild(empty);
                return;
            }

            devices.forEach(device => {
                const statusKey = ['connected', 'connecting', 'disconnected'].includes(device.status) ? device.status : 'disconnected';
                const statusText = device.status ? device.status.charAt(0).toUpperCase() + device.status.slice(1) : 'Unknown';

                const entry = document.createElement('div');
                entry.className = 'device-entry';

                const header = document.createElement('div');
                header.className = 'device-entry-header';

                const info = document.createElement('div');
                info.className = 'device-info';

                const indicator = document.createElement('span');
                indicator.className = `device-status-indicator device-status-${statusKey}`;
                info.appendChild(indicator);

                const ipSpan = document.createElement('span');
                ipSpan.textContent = device.ip;
                info.appendChild(ipSpan);

                header.appendChild(info);

                const buttons = document.createElement('div');
                buttons.className = 'device-entry-buttons';

                const connectBtn = document.createElement('button');
                connectBtn.textContent = device.status === 'connected' ? 'Reconnect' : 'Connect';
                connectBtn.title = connectBtn.textContent;
                connectBtn.style.background = '#1976d2';
                connectBtn.style.color = '#fff';
                connectBtn.onclick = () => {
                    if (device.ws && device.ws.readyState === WebSocket.OPEN) {
                        device.ws.close();
                        setTimeout(() => connectDevice(device), 200);
                    } else {
                        connectDevice(device);
                    }
                };
                connectBtn.disabled = device.status === 'connecting';
                connectBtn.style.opacity = connectBtn.disabled ? '0.5' : '1';

                const disconnectBtn = document.createElement('button');
                disconnectBtn.textContent = 'Disconnect';
                disconnectBtn.title = 'Disconnect';
                disconnectBtn.style.background = '#d32f2f';
                disconnectBtn.style.color = '#fff';
                disconnectBtn.onclick = () => {
                    if (device.ws) {
                        device.ws.close();
                    }
                };
                const isOpen = device.ws && device.ws.readyState === WebSocket.OPEN;
                const isConnecting = device.ws && device.ws.readyState === WebSocket.CONNECTING;
                disconnectBtn.disabled = !(isOpen || isConnecting);
                disconnectBtn.style.opacity = disconnectBtn.disabled ? '0.5' : '1';

                buttons.appendChild(connectBtn);
                buttons.appendChild(disconnectBtn);
                header.appendChild(buttons);
                entry.appendChild(header);

                const statusRow = document.createElement('div');
                statusRow.className = 'device-entry-status';
                statusRow.textContent = `${statusText} • ws://${device.ip}:${device.port}`;
                entry.appendChild(statusRow);

                const downloadState = deviceDownloads[device.id];
                if (downloadState && downloadState.state) {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'device-progress-wrapper';

                    const label = document.createElement('div');
                    label.className = 'device-progress-label';
                    label.textContent = formatDownloadLabel(downloadState);
                    if (downloadState.state === 'completed') {
                        label.style.color = '#9ccc65';
                    } else if (downloadState.state === 'failed') {
                        label.style.color = '#ef9a9a';
                    }

                    const progress = document.createElement('div');
                    progress.className = 'device-progress';

                    const bar = document.createElement('div');
                    bar.className = 'device-progress-bar';
                    if (downloadState.state === 'completed') {
                        bar.classList.add('complete');
                    } else if (downloadState.state === 'failed') {
                        bar.classList.add('failed');
                    }
                    const safeProgress = Math.max(0, Math.min(100, downloadState.progress || 0));
                    bar.style.width = `${safeProgress}%`;

                    progress.appendChild(bar);
                    wrapper.appendChild(label);
                    wrapper.appendChild(progress);

                    if (downloadState.message && downloadState.state === 'failed') {
                        const detail = document.createElement('div');
                        detail.className = 'device-entry-status';
                        detail.style.color = '#ef9a9a';
                        detail.textContent = downloadState.message;
                        wrapper.appendChild(detail);
                    }

                    entry.appendChild(wrapper);
                }

                list.appendChild(entry);
            });
        }

        function formatDownloadLabel(state) {
            const name = state.filename || 'File';
            const folderLabel = state.folder && state.folder !== 'Videos' ? `[${String(state.folder).toUpperCase()}] ` : '';
            const progress = Math.round(state.progress || 0);
            switch (state.state) {
                case 'queued':
                    return `${folderLabel}${name} • Waiting`;
                case 'started':
                    return `${folderLabel}${name} • Starting`;
                case 'progress':
                    return `${folderLabel}${name} • Downloading (${progress}%)`;
                case 'completed':
                    return `${folderLabel}${name} • Ready`;
                case 'failed':
                    return `${folderLabel}${name} • Failed`;
                default:
                    return `${folderLabel}${name}`;
            }
        }

        function getConnectedDevices() {
            return devices.filter(d => d.status === 'connected');
        }

        function setStatus(msg, tone = 'info') {
            const statusEl = document.getElementById('status');
            if (!statusEl) return;
            statusEl.innerText = msg || '';
            const colors = {
                info: '#8bc34a',
                warn: '#ffb74d',
                error: '#ef5350'
            };
            statusEl.style.color = colors[tone] || colors.info;
        }

        function handleDownloadStatus(device, data) {
            const existing = deviceDownloads[device.id] || {};
            const progress = typeof data.progress === 'number' ? Math.max(0, Math.min(100, data.progress)) : (existing.progress || 0);
            const state = data.state || existing.state || 'progress';

            const nextState = {
                filename: data.filename || existing.filename || '',
                folder: data.folder || existing.folder || '',
                state,
                progress,
                message: data.message || ''
            };

            deviceDownloads[device.id] = nextState;
            updateDeviceList();

            if (deviceDownloadTimeouts[device.id]) {
                clearTimeout(deviceDownloadTimeouts[device.id]);
                delete deviceDownloadTimeouts[device.id];
            }

            const labelName = nextState.filename || 'File';
            if (state === 'queued') {
                setStatus(`Queued ${labelName} for ${device.ip}`, 'info');
            } else if (state === 'started') {
                setStatus(`Downloading ${labelName} to ${device.ip}...`, 'info');
            } else if (state === 'progress') {
                setStatus(`Downloading ${labelName} to ${device.ip}: ${Math.round(progress)}%`, 'info');
            } else if (state === 'completed') {
                setStatus(`${labelName} ready on ${device.ip}`, 'info');
                requestVideoList(device);
                deviceDownloadTimeouts[device.id] = setTimeout(() => {
                    delete deviceDownloads[device.id];
                    delete deviceDownloadTimeouts[device.id];
                    updateDeviceList();
                }, 4000);
            } else if (state === 'failed') {
                const errorMsg = nextState.message ? `${labelName} failed on ${device.ip}: ${nextState.message}` : `${labelName} failed on ${device.ip}`;
                setStatus(errorMsg, 'error');
                deviceDownloadTimeouts[device.id] = setTimeout(() => {
                    delete deviceDownloads[device.id];
                    delete deviceDownloadTimeouts[device.id];
                    updateDeviceList();
                }, 7000);
            }
        }

        function toggleMode() {
            is360Mode = !is360Mode;
            const button = document.getElementById('toggleMode');
            button.textContent = is360Mode ? 'Switch to 2D Mode' : 'Switch to 360 Mode';
            getConnectedDevices().forEach(device => {
                device.ws.send(JSON.stringify({ action: 'toggleMode', mode: is360Mode ? '360' : '2D' }));
            });
        }

        function togglePauseResume() {
            const videoPreview = document.getElementById('videoPreview');
            const btn = document.getElementById('pauseResumeBtn');
            if (!btn) return;
            if (previewAvailable && videoPreview && videoPreview.src && videoPreview.style.display !== 'none') {
                if (videoPreview.paused) {
                    getConnectedDevices().forEach(device => {
                        device.ws.send(JSON.stringify({ action: 'resume' }));
                    });
                    videoPreview._programmaticPlay = true;
                    videoPreview.play().catch(() => {});
                    btn.textContent = 'Pause';
                } else {
                    getConnectedDevices().forEach(device => {
                        device.ws.send(JSON.stringify({ action: 'pause' }));
                    });
                    videoPreview._programmaticPause = true;
                    videoPreview.pause();
                    btn.textContent = 'Resume';
                }
            } else {
                if (btn.textContent === 'Pause') {
                    getConnectedDevices().forEach(device => {
                        device.ws.send(JSON.stringify({ action: 'pause' }));
                    });
                    btn.textContent = 'Resume';
                } else {
                    getConnectedDevices().forEach(device => {
                        device.ws.send(JSON.stringify({ action: 'resume' }));
                    });
                    btn.textContent = 'Pause';
                }
            }
        }

        // --- Helper Functions ---

        // --- GLB/GLTF Upload Logic ---
        const glbPanel = document.getElementById('glbPanel');
        const glbDropZone = document.getElementById('glbDropZone');
        const glbDropText = document.getElementById('glbDropText');
        const glbUploadStatus = document.getElementById('glbUploadStatus');
        const glbFileInput = document.getElementById('glbFileInput');
        const glbPreview = document.getElementById('glbPreview');
        const glbPreviewPlaceholder = document.getElementById('glbPreviewPlaceholder');
        let glbPreviewUrl = null;

        // --- Video Upload Logic ---
        const videoUploadPanel = document.getElementById('videoUploadPanel');
        const videoDropZone = document.getElementById('videoDropZone');
        const videoDropText = document.getElementById('videoDropText');
        const videoUploadStatus = document.getElementById('videoUploadStatus');
        const videoFileInput = document.getElementById('videoFileInput');

        function resetDropZone() {
            glbDropZone.classList.remove('hover');
            glbPanel.classList.remove('drag-hover');
            glbDropText.textContent = 'Drag & Drop .glb or .gltf file here, or click to browse';
        }

        let dragCounter = 0;

        async function handleFileSelection(file) {
            if (!file || !/\.(glb|gltf)$/i.test(file.name)) {
                glbUploadStatus.style.color = '#f66';
                glbUploadStatus.textContent = 'Only .glb or .gltf files are supported.';
                return;
            }

            if (glbPreviewUrl) {
                URL.revokeObjectURL(glbPreviewUrl);
                glbPreviewUrl = null;
            }

            glbPreviewUrl = URL.createObjectURL(file);
            glbPreview.src = glbPreviewUrl;
            glbPreview.style.display = 'block';
            glbPreviewPlaceholder.style.display = 'none';

            glbUploadStatus.style.color = '#0f0';
            glbUploadStatus.textContent = `Selected: ${file.name}`;

            // Upload to server and then import to devices
            await uploadAndImportGLB(file);

            glbFileInput.value = '';
        }

        async function uploadAndImportGLB(file) {
            const glbUploadStatus = document.getElementById('glbUploadStatus');
            
            try {
                glbUploadStatus.style.color = '#fdd835';
                glbUploadStatus.textContent = `Uploading ${file.name} to server...`;

                // Check if file already exists on server
                if (!serverGLBs.includes(file.name)) {
                    await uploadFileToServer(file, 'GLB');
                    await fetchServerFiles(); // Refresh server file lists
                }

                glbUploadStatus.textContent = `Checking device availability...`;

                const connectedDevices = getConnectedDevices();
                if (connectedDevices.length === 0) {
                    glbUploadStatus.style.color = '#ff9800';
                    glbUploadStatus.textContent = `${file.name} uploaded to server (no devices connected)`;
                    return;
                }

                // Check which devices have the file
                const devicesNeedingFile = [];
                connectedDevices.forEach(device => {
                    const hasFile = deviceGLBs[device.id] && 
                        deviceGLBs[device.id].some(path => path.includes(file.name));
                    if (!hasFile) {
                        devicesNeedingFile.push(device);
                    }
                });

                // Download to devices that don't have it
                if (devicesNeedingFile.length > 0) {
                    glbUploadStatus.textContent = `Downloading to ${devicesNeedingFile.length} device(s)...`;
                    
                    for (const device of devicesNeedingFile) {
                        await downloadFileToDevice(file.name, 'GLB', device.id);
                    }
                    
                    // Wait a bit for download to complete, then import
                    setTimeout(() => {
                        connectedDevices.forEach(device => {
                            device.ws.send(JSON.stringify({ action: 'importGLB', name: file.name }));
                        });
                    }, 2000);
                    
                    glbUploadStatus.style.color = '#0f0';
                    glbUploadStatus.textContent = `${file.name} uploaded and importing to ${connectedDevices.length} device(s)`;
                } else {
                    // All devices have the file, just import
                    connectedDevices.forEach(device => {
                        device.ws.send(JSON.stringify({ action: 'importGLB', name: file.name }));
                    });
                    
                    glbUploadStatus.style.color = '#0f0';
                    glbUploadStatus.textContent = `${file.name} importing to ${connectedDevices.length} device(s)`;
                }

            } catch (error) {
                glbUploadStatus.style.color = '#f66';
                glbUploadStatus.textContent = `Failed to process ${file.name}: ${error.message}`;
                console.error('GLB upload and import error:', error);
            }
        }



        async function handleVideoSelection(files) {
            if (!files || files.length === 0) {
                videoUploadStatus.style.color = '#f66';
                videoUploadStatus.textContent = 'No video files selected.';
                return;
            }

            const videoExtensions = /\.(mp4|mov|avi|mkv|webm)$/i;
            const validFiles = Array.from(files).filter(file => videoExtensions.test(file.name));
            
            if (validFiles.length === 0) {
                videoUploadStatus.style.color = '#f66';
                videoUploadStatus.textContent = 'Only video files (.mp4, .mov, .avi, .mkv, .webm) are supported.';
                return;
            }

            // Upload videos to server
            for (const file of validFiles) {
                await uploadVideoToServer(file);
            }

            videoFileInput.value = '';
        }

        async function uploadVideoToServer(file) {
            const videoUploadStatus = document.getElementById('videoUploadStatus');
            
            try {
                videoUploadStatus.style.color = '#fdd835';
                videoUploadStatus.textContent = `Uploading ${file.name} to server...`;

                // Determine folder based on filename or ask user
                const folder = file.name.includes('360') ? '360' : '2D';
                
                // Check if file already exists on server
                const existsOnServer = (folder === '2D' && serverVideos2D.includes(file.name)) ||
                                     (folder === '360' && serverVideos360.includes(file.name));

                if (!existsOnServer) {
                    await uploadFileToServer(file, folder);
                    await fetchServerFiles(); // Refresh server file lists
                }

                videoUploadStatus.style.color = '#0f0';
                videoUploadStatus.textContent = `${file.name} uploaded to server (${folder} folder)`;
                
                // Set preview if it's the first file
                setPreviewForPath(file.name);

            } catch (error) {
                videoUploadStatus.style.color = '#f66';
                videoUploadStatus.textContent = `Failed to upload ${file.name}: ${error.message}`;
                console.error('Video upload error:', error);
            }
        }



        function resetVideoDropZone() {
            videoDropZone.classList.remove('hover');
            videoUploadPanel.classList.remove('drag-hover');
            videoDropText.textContent = 'Drag & Drop or click to select video files';
        }

        glbDropZone.addEventListener('dragenter', (e) => {
            e.preventDefault();
            dragCounter++;
            glbDropZone.classList.add('hover');
            glbPanel.classList.add('drag-hover');
            glbDropText.textContent = 'Release to select this file';
        });
        glbDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
        });
        glbDropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dragCounter--;
            if (dragCounter <= 0) {
                resetDropZone();
                dragCounter = 0;
            }
        });
        glbDropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dragCounter = 0;
            resetDropZone();
            const file = e.dataTransfer.files[0];
            handleFileSelection(file);
        });

        glbDropZone.addEventListener('click', () => glbFileInput.click());
        glbFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            handleFileSelection(file);
        });

        // --- Video Drop Zone Event Listeners ---
        let videoDragCounter = 0;

        videoDropZone.addEventListener('dragenter', (e) => {
            e.preventDefault();
            videoDragCounter++;
            videoDropZone.classList.add('hover');
            videoUploadPanel.classList.add('drag-hover');
            videoDropText.textContent = 'Release to select video files';
        });
        videoDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
        });
        videoDropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            videoDragCounter--;
            if (videoDragCounter <= 0) {
                resetVideoDropZone();
                videoDragCounter = 0;
            }
        });
        videoDropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            videoDragCounter = 0;
            resetVideoDropZone();
            const files = e.dataTransfer.files;
            handleVideoSelection(files);
        });

        videoDropZone.addEventListener('click', () => videoFileInput.click());
        videoFileInput.addEventListener('change', (e) => {
            const files = e.target.files;
            handleVideoSelection(files);
        });

        window.addEventListener('beforeunload', () => {
            if (glbPreviewUrl) {
                URL.revokeObjectURL(glbPreviewUrl);
            }
        });
        // --- End GLB/GLTF and Video File Selection Logic ---

        // Initialize page
        function setupPreviewControls() {
            const videoPreview = document.getElementById('videoPreview');
            const btn = document.getElementById('pauseResumeBtn');

            if (!videoPreview || !btn) {
                return;
            }

            videoPreview._programmaticPlay = false;
            videoPreview._programmaticPause = false;
            videoPreview._programmaticSeek = false;

            videoPreview.onplay = () => {
                previewAvailable = true;
                btn.textContent = 'Pause';
                if (!videoPreview._programmaticPlay) {
                    getConnectedDevices().forEach(device => {
                        device.ws.send(JSON.stringify({ action: 'resume' }));
                    });
                }
                videoPreview._programmaticPlay = false;
            };

            videoPreview.onpause = () => {
                btn.textContent = 'Resume';
                if (!videoPreview._programmaticPause) {
                    getConnectedDevices().forEach(device => {
                        device.ws.send(JSON.stringify({ action: 'pause' }));
                    });
                }
                videoPreview._programmaticPause = false;
            };

            videoPreview.addEventListener('seeked', () => {
                if (videoPreview._programmaticSeek) {
                    videoPreview._programmaticSeek = false;
                    return;
                }
                if (previewAvailable) {
                    sendSeek(videoPreview.currentTime);
                }
            });
        }

        function initializePage() {
            setupPreviewControls();
            showPreviewPlaceholder();
            updateDeviceList();
            showVideoList(currentVideoView);
            showGLBList(currentGLBView);
            fetchServerFiles();
        }

        window.addEventListener('load', initializePage);

        // Console helper functions (call from browser console) - Defined at end to ensure all dependencies are loaded

        window.listConnectedDevices = function() {
            const devices = getConnectedDevices();
            console.log('Connected devices:', devices.length);
            devices.forEach((device, index) => {
                console.log(`  ${index + 1}. ${device.name || 'Unnamed Device'} (${device.ip}:${device.port}) - Status: ${device.status}`);
                if (device.ws) {
                    console.log(`    WebSocket State: ${device.ws.readyState} (0=CONNECTING, 1=OPEN, 2=CLOSING, 3=CLOSED)`);
                }
            });
        };

        // Test WebSocket communication
        window.testWebSocket = function() {
            const device = getSelectedDevice();
            if (device && device.ws && device.ws.readyState === WebSocket.OPEN) {
                console.log('Testing WebSocket with listVideos command...');
                device.ws.send(JSON.stringify({ action: 'listVideos' }));
                console.log('Command sent. Check for video list response.');
            } else {
                console.log('No connected WebSocket available for testing.');
            }
        };

        // Debug: Log that functions are defined
        console.log('VR Video Player console functions loaded:');
        console.log('- listConnectedDevices() - Show connected devices and WebSocket status');
        console.log('- testWebSocket() - Test WebSocket with a known working command');
    </script>
</body>
</html>

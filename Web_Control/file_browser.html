<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Headset File Browser</title>
    <style>
        body { 
            margin: 0; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: #1a1a1a; 
            color: #eee; 
            padding: 20px; 
        }
        
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
        }
        
        .header { 
            background: #2d2d2d; 
            padding: 15px; 
            border-radius: 8px; 
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        
        .connection-status { 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            margin-bottom: 15px; 
        }
        
        .status-indicator { 
            width: 12px; 
            height: 12px; 
            border-radius: 50%; 
            background: #ff4444; 
        }
        
        .status-indicator.connected { 
            background: #44ff44; 
        }
        
        .controls { 
            display: flex; 
            gap: 10px; 
            flex-wrap: wrap; 
        }
        
        button { 
            background: #0078d7; 
            color: white; 
            border: none; 
            padding: 8px 16px; 
            border-radius: 4px; 
            cursor: pointer; 
            font-size: 14px;
        }
        
        button:hover { 
            background: #106ebe; 
        }
        
        button:disabled { 
            background: #666; 
            cursor: not-allowed; 
        }
        
        .breadcrumb { 
            background: #333; 
            padding: 10px 15px; 
            border-radius: 6px; 
            margin-bottom: 15px; 
            font-family: 'Courier New', monospace; 
            font-size: 14px;
            word-break: break-all;
        }
        
        .file-browser { 
            background: #2d2d2d; 
            border-radius: 8px; 
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        
        .file-list { 
            max-height: 600px; 
            overflow-y: auto; 
        }
        
        .file-item { 
            display: flex; 
            align-items: center; 
            padding: 12px 15px; 
            border-bottom: 1px solid #404040; 
            cursor: pointer; 
            transition: background 0.2s;
        }
        
        .file-item:hover { 
            background: #3d3d3d; 
        }
        
        .file-item.folder { 
            font-weight: 500; 
        }
        
        .file-icon { 
            width: 20px; 
            margin-right: 12px; 
            text-align: center; 
        }
        
        .file-name { 
            flex: 1; 
            font-size: 14px; 
        }
        
        .file-size { 
            font-size: 12px; 
            color: #aaa; 
            margin-left: 10px;
        }
        
        .back-button { 
            background: #444; 
            color: #fff; 
        }
        
        .back-button:hover { 
            background: #555; 
        }
        
        .loading { 
            text-align: center; 
            padding: 40px; 
            color: #aaa; 
        }
        
        .error { 
            background: #ff4444; 
            color: white; 
            padding: 15px; 
            border-radius: 6px; 
            margin-bottom: 15px; 
        }
        
        .stats { 
            display: flex; 
            gap: 20px; 
            margin-top: 15px; 
            font-size: 12px; 
            color: #aaa; 
        }
        
        .device-input { 
            display: flex; 
            gap: 10px; 
            align-items: center; 
            margin-bottom: 10px; 
        }
        
        input[type="text"] { 
            background: #404040; 
            border: 1px solid #666; 
            color: #eee; 
            padding: 6px 10px; 
            border-radius: 4px; 
            font-size: 14px;
        }
        
        input[type="text"]:focus { 
            outline: none; 
            border-color: #0078d7; 
        }

        .file-item.video {
            background: #2d4a2d;
        }

        .file-item.image {
            background: #4a2d4a;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>VR Headset File Browser</h1>
            
            <div class="device-input">
                <label>Headset IP:</label>
                <input type="text" id="deviceIp" placeholder="192.168.1.238" value="192.168.1.238">
                <label>Port:</label>
                <input type="text" id="devicePort" placeholder="8080" value="8080">
            </div>
            
            <div class="connection-status">
                <div class="status-indicator" id="statusIndicator"></div>
                <span id="statusText">Disconnected</span>
            </div>
            
            <div class="controls">
                <button onclick="connect()" id="connectBtn">Connect</button>
                <button onclick="disconnect()" id="disconnectBtn" disabled>Disconnect</button>
                <button onclick="refreshFolder()" id="refreshBtn" disabled>Refresh</button>
                <button onclick="goToRoot()" id="rootBtn" disabled>Go to Root</button>
                <button onclick="requestPermissions()" id="permissionsBtn" disabled>Request Permissions</button>
                <button onclick="checkAccessibleFolders()" id="accessibleBtn" disabled>Check Accessible Folders</button>
            </div>
        </div>
        
        <div id="errorDiv" class="error" style="display: none;"></div>
        
        <div class="breadcrumb" id="breadcrumb">/</div>
        
        <div class="address-bar" style="margin-bottom: 15px;">
            <div style="display: flex; gap: 10px; align-items: center;">
                <label style="min-width: 60px;">Address:</label>
                <input type="text" id="addressInput" placeholder="/sdcard" 
                       style="flex: 1; padding: 8px; border-radius: 4px; border: 1px solid #666; background: #404040; color: #eee;"
                       onkeypress="if(event.key==='Enter') navigateToAddress()">
                <button onclick="navigateToAddress()" style="padding: 8px 16px;">Go</button>
            </div>
        </div>
        
        <div style="display: flex; gap: 15px;">
            <div class="file-browser" style="flex: 2;">
                <div class="file-list" id="fileList">
                    <div class="loading">Click "Connect" to browse headset files</div>
                </div>
            </div>
            
            <div class="debug-panel" style="flex: 1; background: #2d2d2d; border-radius: 8px; padding: 15px;">
                <h3 style="margin-top: 0;">Debug Logs</h3>
                <div id="debugLog" style="height: 500px; overflow-y: auto; background: #1a1a1a; padding: 10px; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.4;">
                    <div style="color: #666;">Debug messages will appear here...</div>
                </div>
                <button onclick="clearDebugLog()" style="margin-top: 10px; padding: 5px 10px; font-size: 12px;">Clear Logs</button>
            </div>
        </div>
        
        <div class="stats" id="stats"></div>
    </div>

    <script>
        let ws = null;
        let currentPath = '/sdcard';
        let folderStructure = null;
        let currentFolder = null;

        function showStatus(message, isError = false) {
            const statusText = document.getElementById('statusText');
            const statusIndicator = document.getElementById('statusIndicator');
            const errorDiv = document.getElementById('errorDiv');
            
            statusText.textContent = message;
            
            if (isError) {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
                statusIndicator.classList.remove('connected');
            } else {
                errorDiv.style.display = 'none';
                if (message === 'Connected') {
                    statusIndicator.classList.add('connected');
                } else {
                    statusIndicator.classList.remove('connected');
                }
            }
        }

        function updateButtons(connected) {
            document.getElementById('connectBtn').disabled = connected;
            document.getElementById('disconnectBtn').disabled = !connected;
            document.getElementById('refreshBtn').disabled = !connected;
            document.getElementById('rootBtn').disabled = !connected;
            document.getElementById('permissionsBtn').disabled = !connected;
            document.getElementById('accessibleBtn').disabled = !connected;
        }

        function connect() {
            const ip = document.getElementById('deviceIp').value;
            const port = document.getElementById('devicePort').value;
            
            if (!ip) {
                showStatus('Please enter headset IP address', true);
                return;
            }
            
            showStatus('Connecting...');
            
            try {
                ws = new WebSocket(`ws://${ip}:${port}`);
                
                ws.onopen = () => {
                    showStatus('Connected');
                    updateButtons(true);
                    requestFolderStructure();
                };
                
                ws.onclose = () => {
                    showStatus('Disconnected');
                    updateButtons(false);
                    ws = null;
                };
                
                ws.onerror = () => {
                    showStatus('Connection failed', true);
                    updateButtons(false);
                    ws = null;
                };
                
                ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        console.log('WebSocket received:', data.type, data);
                        
                        if (data.type === 'folderStructure') {
                            console.log('Folder structure received:', data.structure);
                            folderStructure = data.structure;
                            currentPath = data.rootPath;
                            currentFolder = {
                                name: data.structure.name,
                                path: data.structure.path,
                                isDirectory: true,
                                children: data.structure.children || []
                            };
                            console.log('Current folder children:', currentFolder.children.length);
                            renderCurrentFolder();
                            updateBreadcrumb(currentPath);
                        } else if (data.type === 'folderContents') {
                            console.log('Folder contents received:', data);
                            if (data.exists) {
                                currentFolder = {
                                    name: data.path.split('/').pop() || data.path,
                                    path: data.path,
                                    isDirectory: true,
                                    children: data.contents || []
                                };
                                currentPath = data.path;
                                console.log(`Folder ${data.path} has ${data.contents?.length || 0} items`);
                                renderCurrentFolder();
                                updateBreadcrumb(currentPath);
                            } else {
                                showStatus(`Folder not found: ${data.path}`, true);
                            }
                        } else if (data.type === 'debugLog') {
                            addDebugLog(data.message, data.timestamp);
                        }
                    } catch (e) {
                        console.error('Error parsing WebSocket message:', e, event.data);
                    }
                };
                
            } catch (e) {
                showStatus('Failed to create WebSocket connection', true);
            }
        }

        function disconnect() {
            if (ws) {
                ws.close();
                ws = null;
            }
            showStatus('Disconnected');
            updateButtons(false);
        }

        function requestFolderStructure() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                showStatus('Loading folder structure...');
                ws.send(JSON.stringify({ action: 'getFolderStructure' }));
            }
        }

        function refreshFolder() {
            requestFolderStructure();
        }

        function goToRoot() {
            if (folderStructure) {
                navigateToFolder({ path: folderStructure.path });
            }
        }

        function navigateToAddress() {
            const address = document.getElementById('addressInput').value.trim();
            if (address && ws && ws.readyState === WebSocket.OPEN) {
                console.log('Navigating to address:', address);
                navigateToFolder({ path: address });
            }
        }

        function requestPermissions() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                addDebugLog('üîê Requesting Android storage permissions...', new Date().toLocaleTimeString());
                ws.send(JSON.stringify({ action: 'requestPermissions' }));
            }
        }

        function checkAccessibleFolders() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                addDebugLog('üîç Checking accessible Android folders...', new Date().toLocaleTimeString());
                ws.send(JSON.stringify({ action: 'getAccessibleFolders' }));
            }
        }

        function updateBreadcrumb(path) {
            document.getElementById('breadcrumb').textContent = path || '/';
            document.getElementById('addressInput').value = path || '/';
        }

        function navigateToFolder(folder) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                showStatus('Loading folder contents...');
                addDebugLog(`üöÄ Requesting folder: ${folder.path}`, new Date().toLocaleTimeString());
                ws.send(JSON.stringify({ action: 'browseFolder', path: folder.path }));
            }
        }

        function goBack() {
            if (currentPath) {
                const parentPath = currentPath.substring(0, currentPath.lastIndexOf('/')) || '/';
                if (parentPath === '/') {
                    // Go back to root
                    goToRoot();
                } else {
                    // Navigate to parent folder
                    navigateToFolder({ path: parentPath });
                }
            }
        }

        function findParentFolder(root, targetPath) {
            if (root.children) {
                for (const child of root.children) {
                    if (child.path === targetPath) {
                        return root;
                    }
                    const found = findParentFolder(child, targetPath);
                    if (found) return found;
                }
            }
            return null;
        }

        function getFileExtension(filename) {
            return filename.toLowerCase().split('.').pop();
        }

        function getFileIcon(item) {
            if (item.isDirectory) return 'üìÅ';
            
            const ext = getFileExtension(item.name);
            const videoExts = ['mp4', 'mov', 'avi', 'mkv', 'webm', 'm4v', '3gp'];
            const imageExts = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg'];
            const audioExts = ['mp3', 'wav', 'flac', 'aac', 'm4a', 'ogg'];
            const docExts = ['txt', 'pdf', 'doc', 'docx', 'rtf'];
            
            if (videoExts.includes(ext)) return 'üé¨';
            if (imageExts.includes(ext)) return 'üñºÔ∏è';
            if (audioExts.includes(ext)) return 'üéµ';
            if (docExts.includes(ext)) return 'üìÑ';
            if (ext === 'apk') return 'üì±';
            if (ext === 'zip' || ext === 'rar' || ext === '7z') return 'üì¶';
            
            return 'üìÑ';
        }

        function getFileClass(item) {
            if (item.isDirectory) return 'folder';
            
            const ext = getFileExtension(item.name);
            const videoExts = ['mp4', 'mov', 'avi', 'mkv', 'webm', 'm4v', '3gp'];
            const imageExts = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg'];
            
            if (videoExts.includes(ext)) return 'video';
            if (imageExts.includes(ext)) return 'image';
            
            return '';
        }

        function formatFileSize(bytes) {
            if (!bytes || bytes === 0) return '';
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return Math.round(bytes / 1024) + ' KB';
            if (bytes < 1024 * 1024 * 1024) return Math.round(bytes / (1024 * 1024)) + ' MB';
            return Math.round(bytes / (1024 * 1024 * 1024)) + ' GB';
        }

        function renderCurrentFolder() {
            const fileList = document.getElementById('fileList');
            const statsDiv = document.getElementById('stats');
            
            if (!currentFolder) {
                fileList.innerHTML = '<div class="loading">No folder data available</div>';
                return;
            }
            
            let html = '';
            let fileCount = 0;
            let folderCount = 0;
            
            // Add back button if not at root
            if (folderStructure && currentFolder.path !== folderStructure.path) {
                html += `
                    <div class="file-item back-button" onclick="goBack()">
                        <div class="file-icon">‚¨ÖÔ∏è</div>
                        <div class="file-name">.. (Go Back)</div>
                    </div>
                `;
            }
            
            if (currentFolder.children && currentFolder.children.length > 0) {
                // Sort: directories first, then files, both alphabetically
                const sorted = [...currentFolder.children].sort((a, b) => {
                    if (a.isDirectory && !b.isDirectory) return -1;
                    if (!a.isDirectory && b.isDirectory) return 1;
                    return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
                });
                
                sorted.forEach(item => {
                    const icon = getFileIcon(item);
                    const fileClass = getFileClass(item);
                    const clickAction = item.isDirectory ? `navigateToFolder(${JSON.stringify(item).replace(/"/g, '&quot;')})` : '';
                    
                    if (item.isDirectory) {
                        folderCount++;
                    } else {
                        fileCount++;
                    }
                    
                    const sizeDisplay = item.isDirectory ? 'Folder' : formatFileSize(item.size);
                    
                    html += `
                        <div class="file-item ${fileClass}" onclick="${clickAction}">
                            <div class="file-icon">${icon}</div>
                            <div class="file-name">${item.name}</div>
                            <div class="file-size">${sizeDisplay}</div>
                        </div>
                    `;
                });
            } else {
                html += '<div class="loading">This folder is empty</div>';
            }
            
            fileList.innerHTML = html;
            
            // Update stats
            statsDiv.innerHTML = `
                <span>üìÅ ${folderCount} folders</span>
                <span>üìÑ ${fileCount} files</span>
                <span>üìç ${currentFolder.path}</span>
            `;
            
            // Update status
            showStatus('Connected');
        }

        function addDebugLog(message, timestamp) {
            const debugLog = document.getElementById('debugLog');
            const logEntry = document.createElement('div');
            logEntry.style.marginBottom = '2px';
            logEntry.innerHTML = `<span style="color: #666;">[${timestamp}]</span> ${message}`;
            debugLog.appendChild(logEntry);
            debugLog.scrollTop = debugLog.scrollHeight; // Auto-scroll to bottom
        }

        function clearDebugLog() {
            document.getElementById('debugLog').innerHTML = '<div style="color: #666;">Debug logs cleared...</div>';
        }

        // Debug function for console testing
        window.testBrowseFolder = function(path) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                console.log('Testing browse folder:', path);
                addDebugLog(`üîç Testing browse folder: ${path}`, new Date().toLocaleTimeString());
                ws.send(JSON.stringify({ action: 'browseFolder', path: path }));
            } else {
                console.log('WebSocket not connected');
                addDebugLog('‚ùå WebSocket not connected', new Date().toLocaleTimeString());
            }
        };

        // Auto-connect on page load if default IP is available
        window.onload = () => {
            const defaultIp = document.getElementById('deviceIp').value;
            if (defaultIp) {
                // Auto-connect after a brief delay to ensure DOM is ready
                setTimeout(() => {
                    connect();
                }, 500);
            }
        };
    </script>
</body>
</html>